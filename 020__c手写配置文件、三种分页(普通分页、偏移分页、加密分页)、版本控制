# ==============================================================================================
上节内容:
	频率:
		-自己定义:
			-定义一个大字典
			-请求来了,取出ip,
			-判断ip是否在大字典中,如果不在,先插入到字典中,然后返回true
			-如果在字典中,根据ip取出列表(时间列表,有顺序,最新的时间在最前面)
			-while循环,判断当前时间,距离最后一条时间,是否大于60s,如果大于60s,pop掉(循环完成,内部没有60s以外的时间)
			-判断列表长度,如果长度小于3,说明还可以访问,把当前时间,插到列表中的第一个位置,然后返回true
			-判断列表长度,如果长度大于等于3,返回false
			
		-内置频率访问的类
			-写一个类继承
				-scope='test'
				-def get_cache_key(self, request, view):
					#以什么做限制,就把什么返回
					return self.get_ident(request)
				
			-跟setting中对应
				    'DEFAULT_THROTTLE_RATES': {
						'test': '10/m'
					}
		-局部使用:
			throttle_classes = [MyThrottle,]
			
		-全局使用:
			在setting中配置
			'DEFAULT_THROTTLE_CLASSES': ['app01.MyAuth.MyThrottle', ],
	认证:
		-认证类return的时候,返回值应该是两个或者是None
		-认证失败,抛异常
		-局部使用
		
		-全局使用
		
	权限:
		-写一个权限类,如果权限认证成功,返回true,失败,返回false
		-局部使用
		-全局使用
	
		
	序列化:
		-写一个类,继承Serializer
		-写一些属性
			-text=CharField()
				-source属性,可以传字段名,可以传方法(source指定的字段名不能跟前面字段名重复)
			-aa=SerializerMethodField()
				-写一个方法:get_字段名(self,对象)
				-在方法内,通过orm查询其他表的数据
				-返回什么,SerializerMethodField对应的字段,就能拿到什么
				
		-使用:视图类
			-生成一个序列化类的对象(instance,data,many)
			-对象.data - 把对象,转成字典/列表
			
		-数据校验保存功能
			
	解析器:
		-局部使用
		-全局使用
		
今日内容:
	视图
		第一种:
			-from rest_framework.mixins import ListModelMixin, CreateModelMixin
			# class PublishView(GenericAPIView, ListModelMixin, CreateModelMixin):
			#     queryset = Publish.objects.all()
			#     serializer_class = PublishSerializers
			#
			#     def get(self, request):
			#         return self.list(request)
			#
			#     def post(self, request):
			#         # 添加一条数据
			#         return self.create(request)
		第二种:
			ListCreateAPIView 继承了GenericAPIView, ListModelMixin, CreateModelMixin
			# class PublishView(GenericAPIView, ListModelMixin, CreateModelMixin):
			# class PublishView(ListCreateAPIView):
			#     queryset = Publish.objects.all()
			#     serializer_class = PublishSerializers
		第三种:
			路由:url(r'^publish/$', views.PublishView.as_view({'get': 'list', 'post': 'create'})),
			    url(r'^publish/(?P<pk>\d+)', views.PublishView.as_view({'get': 'retrieve', 'put': 'update','delete':'destroy'})),
			# from rest_framework.viewsets import ModelViewSet
			# class PublishView(ModelViewSet):
			#     queryset = Publish.objects.all()
			#     serializer_class = PublishSerializers
			
		最终:ViewSetMixin   它有什么作用?用了它之后,视图类中不需要写get,post,put方法了,自己定义方法就可以了
		让请求方法对应到自己定义的方法上,配置路由
		
	路由控制
		三种:
			-一种基本路由:url(r'^publish/$', views.PublishView.as_view()),
			-半自动路径:views.PublishView.as_view({'get': 'list', 'post': 'create'}))
				-必须继承:ViewSetMixin
				-继承ViewSetMixin的先后顺序
			-全自动路由:(基本不用)
				-from rest_framework import routers
				# 生成一个router对象
				router=routers.DefaultRouter()
				# 需要传两个参数,第一个参数就是匹配的路径,第二个参数,是视图类
				router.register('publish',views.PublishView)
				
				
				url('', include(router.urls)),
				#自动生成四个路由(PublishView必须继承ModelViewSet)
				
				
	响应器:(基本上不需要你配置)
		局部配置
		视图类中:
			-renderer_classes=[JSONRenderer,BrowsableAPIRenderer]
		全局配置
		在setting中:
			REST_FRAMEWORK = {
				'DEFAULT_RENDERER_CLASSES':['rest_framework.renderers.JSONRenderer']
			}
			
			

			
作业:
	-上午讲的,写完,整理完
	-from django.conf import settings(不需要全部写)
		-实现的是用户如果配置了,用用户的配置,
		-用户如果没配置,用默认的
		实现
		setting对象:
		setting.DEBUG
# ==============================================================================================
# ==============================================================================================
# ==============================================================================================
app01下的model.py中，

from django.db import models


class Book(models.Model):
    nid = models.AutoField(primary_key=True)
    name = models.CharField(max_length=32)
    price = models.DecimalField(max_digits=5, decimal_places=2)

    def __str__(self):
        return self.name
# ==============================================================================================
settings.py中配置，


INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app01.apps.App01Config',
    #################
    'rest_framework'
]

STATIC_URL = '/static/'

REST_FRAMEWORK = {
    # 每页显示两条
    'PAGE_SIZE':2,
    # 'DEFAULT_VERSIONING_CLASS':'',
    'VERSION_PARAM':'version',
    'DEFAULT_VERSION':'v1',
    'ALLOWED_VERSIONS': ['v1', 'v2'],
}

# ==============================================================================================
app01下的mySer.py文件，

from rest_framework import serializers

from app01 import models


class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.Book
        fields='__all__'
# ==============================================================================================
路由层url.py中，

from django.conf.urls import url,include
from django.contrib import admin
from app01 import views
# from rest_framework import routers
# # 实例化产生一个对象
# router=routers.DefaultRouter()
# # 传两个参数
# router.register('^books',views.Book)

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^(?P<version>[v1|v2|v3]+)/books/$', views.Book.as_view({'get':'get_all'}),name='ttt'),
    url(r'^books/(?P<pk>\d+)', views.Book.as_view({'get':'get_one'})),
    # url(r'a/', include(router.urls))
]
# ==============================================================================================
视图层views.py文件，

from django.shortcuts import render

# Create your views here.
from app01 import models
from rest_framework.viewsets import ViewSetMixin
from rest_framework.views import APIView
from app01 import mySer
from django.http import JsonResponse
from rest_framework.response import Response
# 以后再用settings推荐用它
from django.conf import settings
# class Book(ViewSetMixin, APIView):
#     def get_all(self, request):
#
#         # request.session['my']='ddd'
#         # '''
#         # 生成一个随机字符串:dddsdafadf
#         # dddsdafadf:{my:ddd}
#         # 向cookie中写dddsdafadf
#         # '''
#         # print(settings.AAA)
#
#         # 过滤条件,从GET中取出来
#         response = {'status': 100, 'msg': '查询成功'}
#         book_list = models.Book.objects.all()
#         ser = mySer.BookSerializer(instance=book_list, many=True)
#         response['data'] = ser.data
#         return JsonResponse(response,safe=False)
#         # return Response(response)
#
#     def get_one(self, request,pk):
#         response = {'status': 100, 'msg': '查询成功'}
#         book = models.Book.objects.all().filter(pk=pk).first()
#         if book:
#             ser = mySer.BookSerializer(instance=book, many=False)
#             response['data'] = ser.data
#         else:
#             response['status']=101
#             response['msg']='您要查询的不存在'
#         return Response(response)

# from rest_framework.viewsets import ModelViewSet
#
# from rest_framework.views import  APIView
# class Book(ModelViewSet):
#     queryset = models.Book.objects.all()
#     serializer_class = mySer.BookSerializer

# 普通分页
from rest_framework.pagination import PageNumberPagination
# 偏移分页
from rest_framework.pagination import LimitOffsetPagination
# 加密分页
from rest_framework.pagination import CursorPagination

# class MyPageNumberPagination(PageNumberPagination):
#     # 每页显示多少条
#     page_size = 3
#     # 查询的key,问号后面的key
#     page_query_param = 'aa'
#     # 指定当前页显示多少条
#     page_size_query_param='size'
#     # 每页最多显示多少条
#     max_page_size=4


# class Book(ViewSetMixin, APIView):
#     def get_all(self, request):
#         response = {'status': 100, 'msg': '查询成功'}
#         book_list = models.Book.objects.all()
#         # 实例化产生一个分页对象
#         # 不继承来修改对象的值
#         page=PageNumberPagination()
#         page.page_size=2
#         page.page_query_param='bb'
#         # page = MyPageNumberPagination()
#         # 第一个参数:要分页的数据,第二个参数request对象,第三个参数,当前视图对象
#         page_list = page.paginate_queryset(book_list, request, self)
#         # 再序列化的时候,用分页之后的数据
#         ser = mySer.BookSerializer(instance=page_list, many=True)
#         # response['data'] = ser.data
#         # return Response(response)
#         # 会带着链接,和总共的条数(不建议用)
#         return page.get_paginated_response(ser.data)
#         # return Response(ser.data)
# 偏移分页
# from rest_framework.pagination import LimitOffsetPagination
# class Book(ViewSetMixin, APIView):
#     def get_all(self, request):
#         response = {'status': 100, 'msg': '查询成功'}
#         book_list = models.Book.objects.all()
#         # 实例化产生一个偏移分页对象
#         page=LimitOffsetPagination()
#         page.default_limit=3
#         page.max_limit=5
#
#
#         page_list = page.paginate_queryset(book_list, request, self)
#         ser = mySer.BookSerializer(instance=page_list, many=True)
#         return Response(ser.data)

# from rest_framework.pagination import CursorPagination
#
#
# class Book(ViewSetMixin, APIView):
#     def get_all(self, request):
#         response = {'status': 100, 'msg': '查询成功'}
#         book_list = models.Book.objects.all()
#         # 实例化产生一个加密分页对象
#         page = CursorPagination()
#         page.ordering = 'nid'
#
#         page_list = page.paginate_queryset(book_list, request, self)
#         ser = mySer.BookSerializer(instance=page_list, many=True)
#         return page.get_paginated_response(ser.data)


from rest_framework.pagination import CursorPagination
from rest_framework.versioning import URLPathVersioning, QueryParameterVersioning, AcceptHeaderVersioning


class Book(ViewSetMixin, APIView):
    versioning_class = URLPathVersioning

    def get_all(self, request,*args,**kwargs):

        print(request.version)
        # 路由反向解析
        # from django.urls import reverse
        # url2=reverse(viewname='ttt',kwargs={'version':request.version})
        # print(url2)
        # 提供给咱的解析
        url2=request.versioning_scheme.reverse('ttt',request=request)
        print(url2)
        response = {'status': 100, 'msg': '查询成功'}
        book_list = models.Book.objects.all()
        # 实例化产生一个加密分页对象
        page = CursorPagination()
        page.ordering = 'nid'

        page_list = page.paginate_queryset(book_list, request, self)
        ser = mySer.BookSerializer(instance=page_list, many=True)
        return page.get_paginated_response(ser.data)

# ==============================================================================================
